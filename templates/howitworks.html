<!-- http://jinja.pocoo.org/docs/dev/templates/#template-inheritance -->
{% extends "base.html" %}
{% block title %}critics aren't dead{% endblock %}

{% block content %}
<div class="custom-container container">
    <p><br><br>
    <center><h4>In this project, I created a recommendation engine that matches users with compatible music critics. Users allow Spotify's API to access their
    <a href="https://developer.spotify.com/documentation/web-api/reference/personalization/get-users-top-artists-and-tracks/">top-played tracks</a>,
    and the engine recommends a critic to follow, based on similar music preferences.</h4></center>
    <p><br>
    <h3><b><span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span> How are music preferences determined?</b></h3><h4>
    <p><br>Music preferences are based on Spotify's
    <a href="https://developer.spotify.com/documentation/web-api/reference/tracks/get-audio-features/">audio features</a>
    for each track. These audio features are numerical metrics generated by a combination of proprietary
    <a href="http://docs.echonest.com.s3-website-us-east-1.amazonaws.com/_static/AnalyzeDocumentation.pdf">machine listening techniques</a>
    and the trackâ€™s separate, more complex
    <a href="https://developer.spotify.com/documentation/web-api/reference/tracks/get-audio-analysis/">audio analysis</a>
    of characteristics such as pitch, beats, and tatums.
    <p><p><br>
    <i>For each critic</i>, the algorithm first takes each of his/her reviewed albums and extracts the albums' audio features. One set of audio features is produced for
    each album, and each set's numerical values are weighted by the critic's rating. Finally, these values are averaged per feature, so that a music preference
    "profile" is generated for each critic, consisting of 12 audio features whose values are the weighted averages.
    <p><p><br>
    <i>A similar profile is generated for users</i> of this recommendation engine. Instead of querying album ratings, which are laborious to enter
    and subjective between use cases, the user gives permission for Spotify to access their 50 top-played tracks from the past few months. Each track's audio features
    are extracted and weighted similarly, except weighting in this case is based on the relative ranking of how often each track was played by the user.
    <p></p><br>
    <h3><b><span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span> How are recommendations generated?</b></h3><h4><br>
    After generating the user's audio feature profile, the algorithm takes the difference between each of the user's features and each critic's features. The total difference is
    summed, and the critic with the lowest sum is deemed the "closest" critic to the user. This critic is then presented as the engine's recommendation.
    <p></p><br>
    <h3><b><span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span> Where is the dataset from?</b></h3><h4><br>
    The dataset of music critics (from which recommendations are drawn) is based on a specific SQL database of
    <a href="https://www.kaggle.com/nolanbconaway/pitchfork-data">Pitchfork music critics from 1999-2017</a>, which was assembled
    by Nolan Conaway and posted to Kaggle. After wrangling/cleaning the data, such as removing duplicate, misspelled, or nicknamed names, our dataset totaled
    366 Pitchfork music critics.

    <p><br><p><br></p><center>
    I am currently working on a more detailed post and Github repo of this Flask app.<br>
    In the meantime, here is my <a href="https://github.com/diana-xie/spotify_pitchfork_recommendations">Github project</a> that led to this engine.
    </center><p><br><p><br>

</div>

{% endblock %}